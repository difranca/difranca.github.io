"use strict";(self.webpackChunkdifranca=self.webpackChunkdifranca||[]).push([[57],{5922:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>o});var s=i(5893),r=i(1151);const c={keywords:["software","architecture","code","reuse","shared","library","service","sidecar","mesh"],title:"Code Reuse | Software | Architecture | Tech-Notes",description:"There are several ways in which common components can be shared, especially in distributed architectures.",sidebar_label:"Code Reuse"},t="Code Reuse",a={id:"architecture/software/code-reuse",title:"Code Reuse | Software | Architecture | Tech-Notes",description:"There are several ways in which common components can be shared, especially in distributed architectures.",source:"@site/docs/tech/architecture/software/code-reuse.md",sourceDirName:"architecture/software",slug:"/architecture/software/code-reuse",permalink:"/tech-notes/architecture/software/code-reuse",draft:!1,unlisted:!1,editUrl:"https://github.com/difranca/difranca.github.io/blob/main/docs/tech/architecture/software/code-reuse.md",tags:[],version:"current",frontMatter:{keywords:["software","architecture","code","reuse","shared","library","service","sidecar","mesh"],title:"Code Reuse | Software | Architecture | Tech-Notes",description:"There are several ways in which common components can be shared, especially in distributed architectures.",sidebar_label:"Code Reuse"},sidebar:"tech",previous:{title:"Software",permalink:"/tech-notes/architecture/software"},next:{title:"Programming Languages",permalink:"/tech-notes/languages"}},l={},o=[{value:"Code Replication",id:"code-replication",level:2},{value:"Shared Library",id:"shared-library",level:2},{value:"Shared Service",id:"shared-service",level:2},{value:"Sidecar",id:"sidecar",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"code-reuse",children:"Code Reuse"}),"\n",(0,s.jsx)(n.p,{children:"Common business domain and infrastructure functionalities are typically shared across multiple components."}),"\n",(0,s.jsx)(n.p,{children:"There are several ways in which these components can be shared, especially in distributed architectures."}),"\n",(0,s.jsx)(n.admonition,{title:"More Information",type:"note",children:(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.thoughtworks.com/en-br/insights/books/software-architecture-hard-parts",children:"https://www.thoughtworks.com/en-br/insights/books/software-architecture-hard-parts"})}),"\n"]})}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.h2,{id:"code-replication",children:"Code Replication"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Shared code is copied into each service"}),"\n",(0,s.jsx)(n.li,{children:"Recommended to use it only in exceptional cases"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Advantages:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Preserves the bounded context"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Disadvantages:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Difficult to apply code changes"}),"\n",(0,s.jsx)(n.li,{children:"Code inconsistency across services"}),"\n",(0,s.jsx)(n.li,{children:"No versioning capabilities across services"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Useful for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Simple static code"}),"\n"]}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.h2,{id:"shared-library",children:"Shared Library"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Code is shared in an external artifact (library)"}),"\n",(0,s.jsx)(n.li,{children:"Typically bound to the service at compile time"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Dependency Management:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sharing code into big common libraries (coarse-grained) is easier for dependency management, but it is not good for change control and maintainability"}),"\n",(0,s.jsx)(n.li,{children:"Breaking shared code into small functionality-based libraries (fine-grained) is better for change control and maintainability, but makes dependencies management difficult"}),"\n",(0,s.jsx)(n.li,{children:"It is generally recommended to favor change control over dependency management"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Versioning:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Always use versioning"}),"\n",(0,s.jsx)(n.li,{children:"Version changes must be coordinated and communicated"}),"\n",(0,s.jsx)(n.li,{children:"Create a deprecation strategy"}),"\n",(0,s.jsx)(n.li,{children:"Serious defects or breaking changes to shared code causes all services to adopt the latest version of a shared library at once"}),"\n",(0,s.jsxs)(n.li,{children:["Avoid the use of the ",(0,s.jsx)(n.code,{children:"LATEST"})," version in service requirements"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Advantages:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Ability to version change"}),"\n",(0,s.jsx)(n.li,{children:"Shared code is compile-based, reducing runtime errors"}),"\n",(0,s.jsx)(n.li,{children:"Operational characteristics (e.g. performance, scalability, fault tolerance) are not impacted"}),"\n",(0,s.jsx)(n.li,{children:"Risk of breaking other services with a change to common code is low because of versioning"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Disadvantages:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Dependencies can be difficult to manage"}),"\n",(0,s.jsx)(n.li,{children:"Code duplication in heterogeneous codebases"}),"\n",(0,s.jsx)(n.li,{children:"Version deprecation and communication can be difficult"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Useful for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Homogeneous environments where shared code change is low"}),"\n"]}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.h2,{id:"shared-service",children:"Shared Service"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Places shared functionality in a separately deployed service"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Versioning:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use API endpoint versioning for RESTful APIs"}),"\n",(0,s.jsx)(n.li,{children:"May be harder to implement for other protocols (e.g. gRPC, messaging)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Performance:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Adds network latency"}),"\n",(0,s.jsx)(n.li,{children:"Use of gRPC and messaging can help mitigate some of the performance issues"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Advantages:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Good for high code volatility"}),"\n",(0,s.jsx)(n.li,{children:"No code duplication in heterogeneous codebases"}),"\n",(0,s.jsx)(n.li,{children:"Preserves the bounded context"}),"\n",(0,s.jsx)(n.li,{children:"No static code sharing"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Disadvantages:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Versioning changes can be difficult"}),"\n",(0,s.jsx)(n.li,{children:"Performance is impacted due to latency"}),"\n",(0,s.jsx)(n.li,{children:"Fault tolerance and availability issues due to service dependency"}),"\n",(0,s.jsx)(n.li,{children:"Scalability and throughput issues due to service dependency"}),"\n",(0,s.jsx)(n.li,{children:"Increased risk due to runtime changes"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Useful for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Highly polyglot environments"}),"\n",(0,s.jsx)(n.li,{children:"When shared functionality tends to change often"}),"\n"]}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.h2,{id:"sidecar",children:"Sidecar"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Decouples the domain logic from the technical logic"}),"\n",(0,s.jsx)(n.li,{children:"Same principles may be applied to service mesh"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Advantages:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Consistent way to create isolated coupling"}),"\n",(0,s.jsx)(n.li,{children:"Consistent infrastructure coordination"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Disadvantages:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sidecar component may grow large/complex"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Useful for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Operational coupling"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>a,a:()=>t});var s=i(7294);const r={},c=s.createContext(r);function t(e){const n=s.useContext(c);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(c.Provider,{value:n},e.children)}}}]);